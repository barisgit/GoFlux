package generator

import (
	_ "embed"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"github.com/barisgit/goflux/internal/config"
	"github.com/barisgit/goflux/internal/typegen/types"
	"github.com/barisgit/goflux/templates"
)

//go:embed templates/basic-client.ts.tmpl
var basicClientTemplate string

//go:embed templates/axios-client.ts.tmpl
var axiosClientTemplate string

//go:embed templates/trpc-like-client.ts.tmpl
var trpcLikeClientTemplate string

//go:embed templates/basic-method.ts.tmpl
var basicMethodTemplate string

//go:embed templates/axios-method.ts.tmpl
var axiosMethodTemplate string

//go:embed templates/trpc-get-method.ts.tmpl
var trpcGetMethodTemplate string

//go:embed templates/trpc-mutation-method.ts.tmpl
var trpcMutationMethodTemplate string

// Template data structures
type ClientTemplateData struct {
	UsedTypes         []string
	TypesImport       string
	APIObject         string
	ReactQueryEnabled bool
	QueryKeysEnabled  bool
	QueryKeys         string
}

// MethodTemplateData contains data for individual method templates
type MethodTemplateData struct {
	Description                    string
	Method                         string
	MethodLower                    string
	ParameterSignature             string
	QueryParameterSignature        string
	QueryOptionsParameterSignature string
	ResponseType                   string
	RequestPath                    string
	RequestPathForMutation         string // For React Query mutations with different variable substitution
	HasIDParam                     bool
	HasBodyData                    bool
	DataParameter                  string
	QueryKey                       string
	MutationVariableType           string
	ReactQueryEnabled              bool
}

// GenerateTypeScriptTypes generates TypeScript type definitions
func GenerateTypeScriptTypes(typeDefs []types.TypeDefinition) error {
	typesDir := filepath.Join("frontend", "src", "types")
	if err := os.MkdirAll(typesDir, 0755); err != nil {
		return err
	}

	var content strings.Builder
	content.WriteString("// Auto-generated TypeScript types from Go structs\n")
	content.WriteString("// Generated by GoFlux type generation system\n")
	content.WriteString("// Do not edit manually\n\n")

	// Sort types for consistent output
	sort.Slice(typeDefs, func(i, j int) bool {
		return typeDefs[i].Name < typeDefs[j].Name
	})

	for _, t := range typeDefs {
		if t.IsEnum {
			// Generate enum type
			content.WriteString(fmt.Sprintf("export type %s = %s\n\n",
				t.Name, strings.Join(t.EnumValues, " | ")))
		} else {
			// Generate interface
			content.WriteString(fmt.Sprintf("export interface %s {\n", t.Name))

			for _, field := range t.Fields {
				fieldName := field.JSONTag
				if fieldName == "" {
					fieldName = toSnakeCase(field.Name)
				}

				optional := ""
				if field.Optional {
					optional = "?"
				}

				content.WriteString(fmt.Sprintf("  %s%s: %s\n",
					fieldName, optional, field.TypeName))
			}

			content.WriteString("}\n\n")
		}
	}

	typesFile := filepath.Join(typesDir, "generated.d.ts")
	return os.WriteFile(typesFile, []byte(content.String()), 0644)
}

// GenerateAPIClient generates the TypeScript API client based on configuration
func GenerateAPIClient(routes []types.APIRoute, typeDefs []types.TypeDefinition, config *config.APIClientConfig) error {
	libDir := filepath.Join("frontend", "src", "lib")
	if err := os.MkdirAll(libDir, 0755); err != nil {
		return err
	}

	// Use configured output file name or default
	outputFile := config.OutputFile
	if outputFile == "" {
		outputFile = "api-client.ts"
	}

	// Generate based on selected generator type
	switch config.Generator {
	case "basic":
		return generateBasicClient(routes, typeDefs, config, libDir, outputFile)
	case "axios":
		return generateAxiosClient(routes, typeDefs, config, libDir, outputFile)
	case "trpc-like":
		return generateTRPCLikeClient(routes, typeDefs, config, libDir, outputFile)
	default:
		return fmt.Errorf("unsupported generator type: %s", config.Generator)
	}
}

// GenerateRouteManifest generates a JSON manifest of all routes
func GenerateRouteManifest(routes []types.APIRoute) error {
	manifestDir := filepath.Join("internal", "static")
	if err := os.MkdirAll(manifestDir, 0755); err != nil {
		return err
	}

	manifestFile := filepath.Join(manifestDir, "routes.json")

	data, err := json.MarshalIndent(routes, "", "  ")
	if err != nil {
		return err
	}

	return os.WriteFile(manifestFile, data, 0644)
}

// Helper function to generate a file from an embedded template
func generateFileFromEmbeddedTemplate(templatePath, outputPath string, data interface{}) error {
	// Read template content from embedded filesystem
	content, err := templates.TemplatesFS.ReadFile(templatePath)
	if err != nil {
		return fmt.Errorf("failed to read embedded template %s: %w", templatePath, err)
	}

	// Parse template
	tmpl, err := template.New(filepath.Base(templatePath)).Parse(string(content))
	if err != nil {
		return fmt.Errorf("failed to parse template %s: %w", templatePath, err)
	}

	// Create output directory
	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return fmt.Errorf("failed to create directory for %s: %w", outputPath, err)
	}

	// Create output file
	outputFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file %s: %w", outputPath, err)
	}
	defer outputFile.Close()

	// Execute template
	if err := tmpl.Execute(outputFile, data); err != nil {
		return fmt.Errorf("failed to execute template %s: %w", templatePath, err)
	}

	return nil
}

// Helper function to generate a file from a template (legacy - keeping for compatibility)
func generateFileFromTemplate(templatePath, outputPath string, data interface{}) error {
	// This is now a wrapper that calls the embedded version
	return generateFileFromEmbeddedTemplate(templatePath, outputPath, data)
}

// Helper functions

func buildNestedAPIStructure(routes []types.APIRoute) types.NestedAPI {
	nested := make(types.NestedAPI)

	for _, route := range routes {
		if generateMethodName(route) == "" {
			continue // Skip SSR routes
		}

		path := strings.Replace(route.Path, "/api/", "", 1)
		path = strings.TrimPrefix(path, "/")
		pathParts := strings.Split(path, "/")

		// Filter out parameter parts and build resource hierarchy
		var resourceParts []string
		hasIDParam := false

		for _, part := range pathParts {
			if strings.Contains(part, ":") || strings.HasPrefix(part, "{") {
				hasIDParam = true
				// Don't add parameter parts to resourceParts
			} else if part != "" {
				resourceParts = append(resourceParts, part)
			}
		}

		if len(resourceParts) == 0 {
			continue
		}

		// Determine method name based on HTTP method and context
		methodName := getMethodNameForHTTPMethod(route.Method, hasIDParam, len(resourceParts) > 1)

		method := types.APIMethod{
			Route:       route,
			MethodName:  methodName,
			HasIDParam:  hasIDParam,
			HasBodyData: route.RequestType != "",
		}

		// Build nested structure - but only use the resource parts, not parameters
		current := nested
		for i, part := range resourceParts {
			if i == len(resourceParts)-1 {
				// Last part - this is where we place the method
				if current[part] == nil {
					current[part] = make(types.NestedAPI)
				}
				if nestedPart, ok := current[part].(types.NestedAPI); ok {
					nestedPart[methodName] = method
				}
			} else {
				// Intermediate part - create nested structure
				if current[part] == nil {
					current[part] = make(types.NestedAPI)
				}
				if nestedPart, ok := current[part].(types.NestedAPI); ok {
					current = nestedPart
				}
			}
		}
	}

	return nested
}

func getMethodNameForHTTPMethod(httpMethod string, hasIDParam bool, isNested bool) string {
	switch httpMethod {
	case "GET":
		if hasIDParam {
			return "get"
		}
		return "list"
	case "POST":
		return "create"
	case "PUT", "PATCH":
		return "update"
	case "DELETE":
		return "delete"
	default:
		return strings.ToLower(httpMethod)
	}
}

func generateNestedObject(content *strings.Builder, nested types.NestedAPI, indent int) {
	indentStr := strings.Repeat("  ", indent)

	// Sort keys for consistent output
	keys := make([]string, 0, len(nested))
	for key := range nested {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	for i, key := range keys {
		value := nested[key]

		// Quote key if it contains hyphens or other special characters
		quotedKey := key
		if strings.Contains(key, "-") || strings.Contains(key, " ") || !isValidJSIdentifier(key) {
			quotedKey = fmt.Sprintf(`"%s"`, key)
		}

		switch v := value.(type) {
		case types.APIMethod:
			// Generate the method code first to extract docstring
			templateData := createMethodTemplateData(v, "basic", false)
			methodCode, err := executeMethodTemplate(basicMethodTemplate, templateData)

			if err != nil {
				// Fallback to original approach without docstring extraction
				content.WriteString(fmt.Sprintf("%s%s: ", indentStr, quotedKey))
				generateMethodImplementationLegacy(content, v, indent)
			} else {
				// Extract docstring and method body separately
				lines := strings.Split(methodCode, "\n")
				var docstringLines []string
				var methodBodyLines []string
				inDocstring := false

				for _, line := range lines {
					trimmedLine := strings.TrimSpace(line)
					if strings.HasPrefix(trimmedLine, "/**") {
						inDocstring = true
						docstringLines = append(docstringLines, line)
					} else if inDocstring && strings.HasSuffix(trimmedLine, "*/") {
						inDocstring = false
						docstringLines = append(docstringLines, line)
					} else if inDocstring {
						docstringLines = append(docstringLines, line)
					} else {
						methodBodyLines = append(methodBodyLines, line)
					}
				}

				// Write docstring first (with proper indentation)
				if len(docstringLines) > 0 {
					for _, line := range docstringLines {
						if line != "" {
							content.WriteString(indentStr)
						}
						content.WriteString(line)
						content.WriteString("\n")
					}
				}

				// Write property name and method body
				content.WriteString(fmt.Sprintf("%s%s: ", indentStr, quotedKey))

				// Write method body (skip empty first line if it exists)
				for j, line := range methodBodyLines {
					if j == 0 && strings.TrimSpace(line) == "" {
						continue
					}
					if j > 0 && line != "" {
						content.WriteString(indentStr)
					}
					content.WriteString(line)
					if j < len(methodBodyLines)-1 {
						content.WriteString("\n")
					}
				}
			}
		case types.NestedAPI:
			// Generate nested object
			content.WriteString(fmt.Sprintf("%s%s: {\n", indentStr, quotedKey))
			generateNestedObject(content, v, indent+1)
			content.WriteString(fmt.Sprintf("%s}", indentStr))
		}

		if i < len(keys)-1 {
			content.WriteString(",")
		}
		content.WriteString("\n")
	}
}

func generateMethodImplementation(content *strings.Builder, method types.APIMethod, indent int) {
	// Create method template data
	templateData := createMethodTemplateData(method, "basic", false)

	// Execute the basic method template
	methodCode, err := executeMethodTemplate(basicMethodTemplate, templateData)
	if err != nil {
		// Fallback to original implementation if template fails
		generateMethodImplementationLegacy(content, method, indent)
		return
	}

	// Apply proper indentation to each line
	indentStr := strings.Repeat("  ", indent)
	lines := strings.Split(methodCode, "\n")
	for i, line := range lines {
		if i > 0 && line != "" {
			content.WriteString(indentStr)
		}
		content.WriteString(line)
		if i < len(lines)-1 {
			content.WriteString("\n")
		}
	}
}

// generateMethodImplementationLegacy is the original implementation as fallback
func generateMethodImplementationLegacy(content *strings.Builder, method types.APIMethod, indent int) {
	route := method.Route
	routePath := route.Path[4:] // Remove "/api" prefix

	// Build parameter list
	var params []string
	if method.HasIDParam {
		params = append(params, "id: number")
	}
	if method.HasBodyData {
		requestType := route.RequestType
		if route.Method == "POST" && !strings.Contains(requestType, "Omit") {
			requestType = fmt.Sprintf("Omit<%s, 'id'>", requestType)
		} else if (route.Method == "PUT" || route.Method == "PATCH") && !strings.Contains(requestType, "Partial") {
			requestType = fmt.Sprintf("Partial<%s>", requestType)
		}
		params = append(params, "data: "+requestType)
	}

	responseType := route.ResponseType
	if responseType == "" {
		responseType = "unknown"
	}

	paramStr := strings.Join(params, ", ")

	// Generate async function
	content.WriteString(fmt.Sprintf("async (%s): Promise<ApiResult<%s>> => {\n", paramStr, responseType))

	// Build request path with parameter substitution
	requestPath := routePath

	if method.HasIDParam {
		// Replace both :param and {param} patterns with ${id}
		// Handle :param format (like Express.js)
		re1 := regexp.MustCompile(`/:[^/]+`)
		requestPath = re1.ReplaceAllString(requestPath, "/$${id}")

		// Handle {param} format (like OpenAPI)
		re2 := regexp.MustCompile(`/\{[^}]+\}`)
		requestPath = re2.ReplaceAllString(requestPath, "/$${id}")
	}

	indentStr := strings.Repeat("  ", indent+1)
	if method.HasBodyData {
		content.WriteString(fmt.Sprintf("%sreturn request<%s>(`%s`, {\n", indentStr, responseType, requestPath))
		content.WriteString(fmt.Sprintf("%s  method: '%s',\n", indentStr, route.Method))
		content.WriteString(fmt.Sprintf("%s  body: JSON.stringify(data),\n", indentStr))
		content.WriteString(fmt.Sprintf("%s})\n", indentStr))
	} else {
		if route.Method == "GET" {
			content.WriteString(fmt.Sprintf("%sreturn request<%s>(`%s`)\n", indentStr, responseType, requestPath))
		} else {
			content.WriteString(fmt.Sprintf("%sreturn request<%s>(`%s`, { method: '%s' })\n", indentStr, responseType, requestPath, route.Method))
		}
	}

	content.WriteString(fmt.Sprintf("%s}", strings.Repeat("  ", indent)))
}

func generateMethodName(route types.APIRoute) string {
	path := strings.Replace(route.Path, "/api/", "", 1)
	path = strings.TrimPrefix(path, "/")

	// Skip SSR routes
	if strings.Contains(path, "ssr-data") {
		return ""
	}

	// Handle nested routes like /users/:id/profile
	pathParts := strings.Split(path, "/")
	var resourceParts []string
	var hasIDParam bool

	for _, part := range pathParts {
		if strings.Contains(part, ":") {
			hasIDParam = true
		} else if part != "" {
			// Clean up invalid characters
			cleanPart := strings.ReplaceAll(part, "-", "")
			cleanPart = strings.ReplaceAll(cleanPart, ":", "")
			resourceParts = append(resourceParts, cleanPart)
		}
	}

	if len(resourceParts) == 0 {
		return ""
	}

	// Build method name based on route structure
	var methodName string
	switch route.Method {
	case "GET":
		if hasIDParam {
			// For nested routes like /users/:id/profile -> getUserProfile
			if len(resourceParts) > 1 {
				methodName = "get" + capitalize(singularize(resourceParts[0])) + capitalize(resourceParts[1])
			} else {
				methodName = "get" + capitalize(singularize(resourceParts[0]))
			}
		} else {
			// For list routes like /users -> getUsers
			if len(resourceParts) > 1 {
				methodName = "get" + capitalize(resourceParts[0]) + capitalize(resourceParts[1])
			} else {
				methodName = "get" + capitalize(resourceParts[0])
			}
		}
	case "POST":
		if len(resourceParts) > 1 {
			methodName = "create" + capitalize(singularize(resourceParts[0])) + capitalize(resourceParts[1])
		} else {
			methodName = "create" + capitalize(singularize(resourceParts[0]))
		}
	case "PUT", "PATCH":
		if len(resourceParts) > 1 {
			methodName = "update" + capitalize(singularize(resourceParts[0])) + capitalize(resourceParts[1])
		} else {
			methodName = "update" + capitalize(singularize(resourceParts[0]))
		}
	case "DELETE":
		if len(resourceParts) > 1 {
			methodName = "delete" + capitalize(singularize(resourceParts[0])) + capitalize(resourceParts[1])
		} else {
			methodName = "delete" + capitalize(singularize(resourceParts[0]))
		}
	default:
		methodName = strings.ToLower(route.Method) + capitalize(strings.Join(resourceParts, ""))
	}

	return methodName
}

func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r - 'A' + 'a')
	}
	return result.String()
}

func capitalize(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func singularize(s string) string {
	if strings.HasSuffix(s, "s") && len(s) > 1 {
		return s[:len(s)-1]
	}
	return s
}

func isValidJSIdentifier(s string) bool {
	if s == "" {
		return false
	}

	// Check if the first character is valid (letter, underscore, or dollar sign)
	firstChar := rune(s[0])
	if !((firstChar >= 'a' && firstChar <= 'z') ||
		(firstChar >= 'A' && firstChar <= 'Z') ||
		firstChar == '_' || firstChar == '$') {
		return false
	}

	// Check if remaining characters are valid (letters, digits, underscores, or dollar signs)
	for _, char := range s[1:] {
		if !((char >= 'a' && char <= 'z') ||
			(char >= 'A' && char <= 'Z') ||
			(char >= '0' && char <= '9') ||
			char == '_' || char == '$') {
			return false
		}
	}

	return true
}

// generateBasicClient generates the original basic API client
func generateBasicClient(routes []types.APIRoute, typeDefs []types.TypeDefinition, config *config.APIClientConfig, libDir, outputFile string) error {
	usedTypes := collectUsedTypes(routes, typeDefs)
	apiObject := generateAPIObjectString(routes, "basic")

	data := ClientTemplateData{
		UsedTypes:   usedTypes,
		TypesImport: config.TypesImport,
		APIObject:   apiObject,
	}

	return generateFromTemplate(basicClientTemplate, data, filepath.Join(libDir, outputFile))
}

// generateAxiosClient generates an Axios-based API client
func generateAxiosClient(routes []types.APIRoute, typeDefs []types.TypeDefinition, config *config.APIClientConfig, libDir, outputFile string) error {
	usedTypes := collectUsedTypes(routes, typeDefs)
	apiObject := generateAPIObjectString(routes, "axios")

	data := ClientTemplateData{
		UsedTypes:   usedTypes,
		TypesImport: config.TypesImport,
		APIObject:   apiObject,
	}

	return generateFromTemplate(axiosClientTemplate, data, filepath.Join(libDir, outputFile))
}

// generateTRPCLikeClient generates a tRPC-like API client with React Query integration
func generateTRPCLikeClient(routes []types.APIRoute, typeDefs []types.TypeDefinition, config *config.APIClientConfig, libDir, outputFile string) error {
	usedTypes := collectUsedTypes(routes, typeDefs)
	apiObject := generateTRPCAPIObjectString(routes, config)

	var queryKeys string
	if config.ReactQuery.QueryKeys {
		queryKeys = generateQueryKeys(routes)
	}

	data := ClientTemplateData{
		UsedTypes:         usedTypes,
		TypesImport:       config.TypesImport,
		APIObject:         apiObject,
		ReactQueryEnabled: config.ReactQuery.Enabled,
		QueryKeysEnabled:  config.ReactQuery.QueryKeys,
		QueryKeys:         queryKeys,
	}

	return generateFromTemplate(trpcLikeClientTemplate, data, filepath.Join(libDir, outputFile))
}

// generateFromTemplate creates a file from an embedded template
func generateFromTemplate(templateStr string, data ClientTemplateData, outputPath string) error {
	// Create custom function map for templates
	funcMap := template.FuncMap{
		"join": strings.Join,
	}

	tmpl, err := template.New("client").Funcs(funcMap).Parse(templateStr)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create output directory
	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return fmt.Errorf("failed to create directory for %s: %w", outputPath, err)
	}

	// Create output file
	outputFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file %s: %w", outputPath, err)
	}
	defer outputFile.Close()

	// Execute template
	if err := tmpl.Execute(outputFile, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

// generateTRPCAPIObjectString generates tRPC-like API object with React Query hooks
func generateTRPCAPIObjectString(routes []types.APIRoute, config *config.APIClientConfig) string {
	var content strings.Builder
	nestedAPI := buildNestedAPIStructure(routes)

	content.WriteString("export const api = {\n")
	generateTRPCNestedObject(&content, nestedAPI, config, 1)
	content.WriteString("}")
	return content.String()
}

// generateTRPCNestedObject generates tRPC-like nested structure with React Query hooks
func generateTRPCNestedObject(content *strings.Builder, nested types.NestedAPI, config *config.APIClientConfig, indent int) {
	indentStr := strings.Repeat("  ", indent)

	// Sort keys for consistent output
	keys := make([]string, 0, len(nested))
	for key := range nested {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	for i, key := range keys {
		value := nested[key]

		quotedKey := key
		if strings.Contains(key, "-") || strings.Contains(key, " ") || !isValidJSIdentifier(key) {
			quotedKey = fmt.Sprintf(`"%s"`, key)
		}

		switch v := value.(type) {
		case types.APIMethod:
			// Generate the method code first to extract docstring
			var methodCode string
			var err error

			templateData := createMethodTemplateData(v, "trpc-like", config.ReactQuery.Enabled)

			if v.Route.Method == "GET" {
				methodCode, err = executeMethodTemplate(trpcGetMethodTemplate, templateData)
			} else {
				methodCode, err = executeMethodTemplate(trpcMutationMethodTemplate, templateData)
			}

			if err != nil {
				// Fallback to original approach without docstring extraction
				content.WriteString(fmt.Sprintf("%s%s: ", indentStr, quotedKey))
				if config.ReactQuery.Enabled {
					generateTRPCMethodWithReactQueryLegacy(content, v, indent)
				} else {
					generateTRPCMethodImplementationLegacy(content, v, indent)
				}
			} else {
				// Extract docstring and method body separately
				lines := strings.Split(methodCode, "\n")
				var docstringLines []string
				var methodBodyLines []string
				inDocstring := false

				for _, line := range lines {
					trimmedLine := strings.TrimSpace(line)
					if strings.HasPrefix(trimmedLine, "/**") {
						inDocstring = true
						docstringLines = append(docstringLines, line)
					} else if inDocstring && strings.HasSuffix(trimmedLine, "*/") {
						inDocstring = false
						docstringLines = append(docstringLines, line)
					} else if inDocstring {
						docstringLines = append(docstringLines, line)
					} else {
						methodBodyLines = append(methodBodyLines, line)
					}
				}

				// Write docstring first (with proper indentation)
				if len(docstringLines) > 0 {
					for _, line := range docstringLines {
						if line != "" {
							content.WriteString(indentStr)
						}
						content.WriteString(line)
						content.WriteString("\n")
					}
				}

				// Write property name and method body
				content.WriteString(fmt.Sprintf("%s%s: ", indentStr, quotedKey))

				// Write method body (skip empty first line if it exists)
				for j, line := range methodBodyLines {
					if j == 0 && strings.TrimSpace(line) == "" {
						continue
					}
					if j > 0 && line != "" {
						content.WriteString(indentStr)
					}
					content.WriteString(line)
					if j < len(methodBodyLines)-1 {
						content.WriteString("\n")
					}
				}
			}
		case types.NestedAPI:
			content.WriteString(fmt.Sprintf("%s%s: {\n", indentStr, quotedKey))
			generateTRPCNestedObject(content, v, config, indent+1)
			content.WriteString(fmt.Sprintf("%s}", indentStr))
		}

		if i < len(keys)-1 {
			content.WriteString(",")
		}
		content.WriteString("\n")
	}
}

// generateTRPCMethodImplementation generates basic tRPC method without React Query
func generateTRPCMethodImplementation(content *strings.Builder, method types.APIMethod, indent int) {
	// Create method template data
	templateData := createMethodTemplateData(method, "trpc-like", false)

	// For basic tRPC methods, use simple template or execute inline
	var methodCode string
	var err error

	if method.Route.Method == "GET" {
		methodCode, err = executeMethodTemplate(trpcGetMethodTemplate, templateData)
	} else {
		methodCode, err = executeMethodTemplate(trpcMutationMethodTemplate, templateData)
	}

	if err != nil {
		// Fallback to original implementation if template fails
		generateTRPCMethodImplementationLegacy(content, method, indent)
		return
	}

	// Apply proper indentation to each line
	indentStr := strings.Repeat("  ", indent)
	lines := strings.Split(methodCode, "\n")
	for i, line := range lines {
		if i > 0 && line != "" {
			content.WriteString(indentStr)
		}
		content.WriteString(line)
		if i < len(lines)-1 {
			content.WriteString("\n")
		}
	}
}

// generateTRPCMethodImplementationLegacy is the original implementation as fallback
func generateTRPCMethodImplementationLegacy(content *strings.Builder, method types.APIMethod, indent int) {
	route := method.Route
	routePath := route.Path[4:] // Remove "/api" prefix

	// Build parameter list
	var params []string
	if method.HasIDParam {
		params = append(params, "id: number")
	}
	if method.HasBodyData {
		requestType := route.RequestType
		if route.Method == "POST" && !strings.Contains(requestType, "Omit") {
			requestType = fmt.Sprintf("Omit<%s, 'id'>", requestType)
		} else if (route.Method == "PUT" || route.Method == "PATCH") && !strings.Contains(requestType, "Partial") {
			requestType = fmt.Sprintf("Partial<%s>", requestType)
		}
		params = append(params, "data: "+requestType)
	}

	responseType := route.ResponseType
	if responseType == "" {
		responseType = "unknown"
	}

	paramStr := strings.Join(params, ", ")

	// Build request path with parameter substitution
	requestPath := routePath
	if method.HasIDParam {
		re1 := regexp.MustCompile(`/:[^/]+`)
		requestPath = re1.ReplaceAllString(requestPath, "/$${id}")
		re2 := regexp.MustCompile(`/\{[^}]+\}`)
		requestPath = re2.ReplaceAllString(requestPath, "/$${id}")
	}

	// Generate async function
	content.WriteString(fmt.Sprintf("async (%s): Promise<%s> => {\n", paramStr, responseType))
	indentStr := strings.Repeat("  ", indent+1)

	if method.HasBodyData {
		content.WriteString(fmt.Sprintf("%sreturn trpcRequest<%s>(`%s`, {\n", indentStr, responseType, requestPath))
		content.WriteString(fmt.Sprintf("%s  method: '%s',\n", indentStr, route.Method))
		content.WriteString(fmt.Sprintf("%s  body: JSON.stringify(data),\n", indentStr))
		content.WriteString(fmt.Sprintf("%s})\n", indentStr))
	} else {
		if route.Method == "GET" {
			content.WriteString(fmt.Sprintf("%sreturn trpcRequest<%s>(`%s`)\n", indentStr, responseType, requestPath))
		} else {
			content.WriteString(fmt.Sprintf("%sreturn trpcRequest<%s>(`%s`, { method: '%s' })\n", indentStr, responseType, requestPath, route.Method))
		}
	}

	content.WriteString(fmt.Sprintf("%s}", strings.Repeat("  ", indent)))
}

// generateTRPCMethodWithReactQuery generates tRPC method with React Query hooks
func generateTRPCMethodWithReactQuery(content *strings.Builder, method types.APIMethod, indent int) {
	// Create method template data with React Query enabled
	templateData := createMethodTemplateData(method, "trpc-like", true)

	var methodCode string
	var err error

	if method.Route.Method == "GET" {
		methodCode, err = executeMethodTemplate(trpcGetMethodTemplate, templateData)
	} else {
		methodCode, err = executeMethodTemplate(trpcMutationMethodTemplate, templateData)
	}

	if err != nil {
		// Fallback to original implementation if template fails
		generateTRPCMethodWithReactQueryLegacy(content, method, indent)
		return
	}

	// Apply proper indentation to each line
	indentStr := strings.Repeat("  ", indent)
	lines := strings.Split(methodCode, "\n")
	for i, line := range lines {
		if i > 0 && line != "" {
			content.WriteString(indentStr)
		}
		content.WriteString(line)
		if i < len(lines)-1 {
			content.WriteString("\n")
		}
	}
}

// generateTRPCMethodWithReactQueryLegacy is the original implementation as fallback
func generateTRPCMethodWithReactQueryLegacy(content *strings.Builder, method types.APIMethod, indent int) {
	route := method.Route
	responseType := route.ResponseType
	if responseType == "" {
		responseType = "unknown"
	}

	if route.Method == "GET" {
		// Build request path with parameter substitution for queryFn
		requestPath := route.Path[4:] // Remove "/api" prefix
		if method.HasIDParam {
			re1 := regexp.MustCompile(`/:[^/]+`)
			requestPath = re1.ReplaceAllString(requestPath, "/$${id}")
			re2 := regexp.MustCompile(`/\{[^}]+\}`)
			requestPath = re2.ReplaceAllString(requestPath, "/$${id}")
		}

		// Generate GET method object
		content.WriteString("{\n")

		// Generate useQuery hook
		content.WriteString(fmt.Sprintf("%s  useQuery: (", strings.Repeat("  ", indent+1)))
		if method.HasIDParam {
			content.WriteString("id: number, ")
		}
		content.WriteString(fmt.Sprintf("options?: Omit<UseQueryOptions<%s, Error>, 'queryKey' | 'queryFn'>) => {\n", responseType))
		content.WriteString(fmt.Sprintf("%s    return useQuery({\n", strings.Repeat("  ", indent+1)))
		content.WriteString(fmt.Sprintf("%s      queryKey: ['%s'", strings.Repeat("  ", indent+1), strings.TrimPrefix(route.Path, "/api/")))
		if method.HasIDParam {
			content.WriteString(", id")
		}
		content.WriteString("],\n")
		if method.HasIDParam {
			content.WriteString(fmt.Sprintf("%s      queryFn: () => trpcRequest<%s>(`%s`),\n", strings.Repeat("  ", indent+1), responseType, requestPath))
		} else {
			content.WriteString(fmt.Sprintf("%s      queryFn: () => trpcRequest<%s>(`%s`),\n", strings.Repeat("  ", indent+1), responseType, requestPath))
		}
		content.WriteString(fmt.Sprintf("%s      ...options,\n", strings.Repeat("  ", indent+1)))
		content.WriteString(fmt.Sprintf("%s    })\n", strings.Repeat("  ", indent+1)))
		content.WriteString(fmt.Sprintf("%s  },\n", strings.Repeat("  ", indent+1)))

		// Generate queryOptions function
		content.WriteString(fmt.Sprintf("%s  queryOptions: (", strings.Repeat("  ", indent+1)))
		if method.HasIDParam {
			content.WriteString("id: number")
		}
		content.WriteString(fmt.Sprintf(") => queryOptions({\n"))
		content.WriteString(fmt.Sprintf("%s    queryKey: ['%s'", strings.Repeat("  ", indent+1), strings.TrimPrefix(route.Path, "/api/")))
		if method.HasIDParam {
			content.WriteString(", id")
		}
		content.WriteString("] as const,\n")
		if method.HasIDParam {
			content.WriteString(fmt.Sprintf("%s    queryFn: () => trpcRequest<%s>(`%s`),\n", strings.Repeat("  ", indent+1), responseType, requestPath))
		} else {
			content.WriteString(fmt.Sprintf("%s    queryFn: () => trpcRequest<%s>(`%s`),\n", strings.Repeat("  ", indent+1), responseType, requestPath))
		}
		content.WriteString(fmt.Sprintf("%s  }),\n", strings.Repeat("  ", indent+1)))

		// Also provide the raw function
		content.WriteString(fmt.Sprintf("%s  query: ", strings.Repeat("  ", indent+1)))
		generateTRPCMethodImplementationLegacy(content, method, indent+1)
		content.WriteString(fmt.Sprintf("\n%s}", strings.Repeat("  ", indent)))
	} else {
		// Generate mutation method object for POST/PUT/DELETE
		content.WriteString("{\n")

		// Build parameter types for mutation
		var mutationVariableType string

		if method.HasIDParam && method.HasBodyData {
			requestType := route.RequestType
			if route.Method == "POST" && !strings.Contains(requestType, "Omit") {
				requestType = fmt.Sprintf("Omit<%s, 'id'>", requestType)
			} else if (route.Method == "PUT" || route.Method == "PATCH") && !strings.Contains(requestType, "Partial") {
				requestType = fmt.Sprintf("Partial<%s>", requestType)
			}
			mutationVariableType = fmt.Sprintf("{ id: number; data: %s }", requestType)
		} else if method.HasIDParam {
			mutationVariableType = "number"
		} else if method.HasBodyData {
			requestType := route.RequestType
			if route.Method == "POST" && !strings.Contains(requestType, "Omit") {
				requestType = fmt.Sprintf("Omit<%s, 'id'>", requestType)
			} else if (route.Method == "PUT" || route.Method == "PATCH") && !strings.Contains(requestType, "Partial") {
				requestType = fmt.Sprintf("Partial<%s>", requestType)
			}
			mutationVariableType = requestType
		} else {
			mutationVariableType = "void"
		}

		// Generate useMutation hook
		content.WriteString(fmt.Sprintf("%s  useMutation: (options?: UseMutationOptions<%s, Error, %s>) => {\n", strings.Repeat("  ", indent+1), responseType, mutationVariableType))
		content.WriteString(fmt.Sprintf("%s    return useMutation({\n", strings.Repeat("  ", indent+1)))
		content.WriteString(fmt.Sprintf("%s      mutationFn: (variables) => {\n", strings.Repeat("  ", indent+1)))

		// Generate the actual API call
		requestPath := route.Path[4:] // Remove "/api" prefix
		if method.HasIDParam {
			if method.HasBodyData {
				// Use variables.id for PUT/PATCH with both ID and body
				re1 := regexp.MustCompile(`/:[^/]+`)
				requestPath = re1.ReplaceAllString(requestPath, "/$${variables.id}")
				re2 := regexp.MustCompile(`/\{[^}]+\}`)
				requestPath = re2.ReplaceAllString(requestPath, "/$${variables.id}")
			} else {
				// Use variables directly for DELETE
				re1 := regexp.MustCompile(`/:[^/]+`)
				requestPath = re1.ReplaceAllString(requestPath, "/$${variables}")
				re2 := regexp.MustCompile(`/\{[^}]+\}`)
				requestPath = re2.ReplaceAllString(requestPath, "/$${variables}")
			}
		}

		if method.HasBodyData {
			content.WriteString(fmt.Sprintf("%s        return trpcRequest<%s>(`%s`, {\n", strings.Repeat("  ", indent+1), responseType, requestPath))
			content.WriteString(fmt.Sprintf("%s          method: '%s',\n", strings.Repeat("  ", indent+1), route.Method))
			if method.HasBodyData && method.HasIDParam {
				content.WriteString(fmt.Sprintf("%s          body: JSON.stringify(variables.data),\n", strings.Repeat("  ", indent+1)))
			} else {
				content.WriteString(fmt.Sprintf("%s          body: JSON.stringify(variables),\n", strings.Repeat("  ", indent+1)))
			}
			content.WriteString(fmt.Sprintf("%s        })\n", strings.Repeat("  ", indent+1)))
		} else {
			content.WriteString(fmt.Sprintf("%s        return trpcRequest<%s>(`%s`, { method: '%s' })\n", strings.Repeat("  ", indent+1), responseType, requestPath, route.Method))
		}

		content.WriteString(fmt.Sprintf("%s      },\n", strings.Repeat("  ", indent+1)))
		content.WriteString(fmt.Sprintf("%s      ...options,\n", strings.Repeat("  ", indent+1)))
		content.WriteString(fmt.Sprintf("%s    })\n", strings.Repeat("  ", indent+1)))

		// Generate mutationOptions function
		content.WriteString(fmt.Sprintf("%s  },\n", strings.Repeat("  ", indent+1)))
		content.WriteString(fmt.Sprintf("%s  mutationOptions: (options?: Omit<UseMutationOptions<%s, Error, %s>, 'mutationFn'>) => ({\n", strings.Repeat("  ", indent+1), responseType, mutationVariableType))
		content.WriteString(fmt.Sprintf("%s    mutationFn: (variables: %s) => {\n", strings.Repeat("  ", indent+1), mutationVariableType))

		// Same API call logic as above
		if method.HasBodyData {
			content.WriteString(fmt.Sprintf("%s      return trpcRequest<%s>(`%s`, {\n", strings.Repeat("  ", indent+1), responseType, requestPath))
			content.WriteString(fmt.Sprintf("%s        method: '%s',\n", strings.Repeat("  ", indent+1), route.Method))
			if method.HasBodyData && method.HasIDParam {
				content.WriteString(fmt.Sprintf("%s        body: JSON.stringify(variables.data),\n", strings.Repeat("  ", indent+1)))
			} else {
				content.WriteString(fmt.Sprintf("%s        body: JSON.stringify(variables),\n", strings.Repeat("  ", indent+1)))
			}
			content.WriteString(fmt.Sprintf("%s      })\n", strings.Repeat("  ", indent+1)))
		} else {
			content.WriteString(fmt.Sprintf("%s      return trpcRequest<%s>(`%s`, { method: '%s' })\n", strings.Repeat("  ", indent+1), responseType, requestPath, route.Method))
		}

		content.WriteString(fmt.Sprintf("%s    },\n", strings.Repeat("  ", indent+1)))
		content.WriteString(fmt.Sprintf("%s    ...options,\n", strings.Repeat("  ", indent+1)))
		content.WriteString(fmt.Sprintf("%s  }),\n", strings.Repeat("  ", indent+1)))

		// Also provide the raw function
		content.WriteString(fmt.Sprintf("%s  mutate: ", strings.Repeat("  ", indent+1)))
		generateTRPCMethodImplementationLegacy(content, method, indent+1)
		content.WriteString(fmt.Sprintf("\n%s}", strings.Repeat("  ", indent)))
	}
}

// collectUsedTypes extracts all types used in the API routes
func collectUsedTypes(routes []types.APIRoute, typeDefs []types.TypeDefinition) []string {
	usedTypes := make(map[string]bool)

	for _, route := range routes {
		if route.RequestType != "" {
			// Extract base type from Omit<Type, 'id'> or Partial<Type>
			requestType := route.RequestType
			if strings.Contains(requestType, "Omit<") {
				start := strings.Index(requestType, "Omit<") + 5
				end := strings.Index(requestType[start:], ",")
				if end > 0 {
					usedTypes[requestType[start:start+end]] = true
				}
			} else if strings.Contains(requestType, "Partial<") {
				start := strings.Index(requestType, "Partial<") + 8
				end := strings.Index(requestType[start:], ">")
				if end > 0 {
					usedTypes[requestType[start:start+end]] = true
				}
			} else {
				usedTypes[requestType] = true
			}
		}
		if route.ResponseType != "" {
			responseType := route.ResponseType
			// Handle array types like "User[]"
			if strings.TrimSuffix(responseType, "[]") != responseType {
				responseType = strings.TrimSuffix(responseType, "[]")
			}
			usedTypes[responseType] = true
		}
	}

	// Filter to only include types that exist in our generated types
	var typeNames []string
	for typeName := range usedTypes {
		for _, t := range typeDefs {
			if t.Name == typeName {
				typeNames = append(typeNames, typeName)
				break
			}
		}
	}

	sort.Strings(typeNames)
	return typeNames
}

// generateAPIObjectString generates the API object as a string
func generateAPIObjectString(routes []types.APIRoute, generatorType string) string {
	var content strings.Builder
	nestedAPI := buildNestedAPIStructure(routes)

	content.WriteString("export const api = {\n")

	switch generatorType {
	case "axios":
		generateAxiosNestedObject(&content, nestedAPI, 1)
	case "trpc-like":
		// Will be handled separately for tRPC-like
		generateNestedObject(&content, nestedAPI, 1)
	default:
		generateNestedObject(&content, nestedAPI, 1)
	}

	content.WriteString("}")
	return content.String()
}

// generateQueryKeys generates query key factory functions
func generateQueryKeys(routes []types.APIRoute) string {
	var content strings.Builder
	resources := make(map[string]bool)

	// Extract unique resources
	for _, route := range routes {
		if route.Method == "GET" {
			path := strings.Replace(route.Path, "/api/", "", 1)
			pathParts := strings.Split(path, "/")
			if len(pathParts) > 0 && pathParts[0] != "" {
				resources[pathParts[0]] = true
			}
		}
	}

	// Generate key factory for each resource
	indent := "  "
	for resource := range resources {
		content.WriteString(fmt.Sprintf("%s%s: {\n", indent, resource))
		content.WriteString(fmt.Sprintf("%s  all: () => ['%s'] as const,\n", indent, resource))
		content.WriteString(fmt.Sprintf("%s  list: () => [...queryKeys.%s.all(), 'list'] as const,\n", indent, resource))
		content.WriteString(fmt.Sprintf("%s  detail: (id: string | number) => [...queryKeys.%s.all(), 'detail', id] as const,\n", indent, resource))
		content.WriteString(fmt.Sprintf("%s},\n", indent))
	}

	return content.String()
}

// generateAxiosNestedObject generates Axios-style API methods
func generateAxiosNestedObject(content *strings.Builder, nested types.NestedAPI, indent int) {
	indentStr := strings.Repeat("  ", indent)

	// Sort keys for consistent output
	keys := make([]string, 0, len(nested))
	for key := range nested {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	for i, key := range keys {
		value := nested[key]

		quotedKey := key
		if strings.Contains(key, "-") || strings.Contains(key, " ") || !isValidJSIdentifier(key) {
			quotedKey = fmt.Sprintf(`"%s"`, key)
		}

		switch v := value.(type) {
		case types.APIMethod:
			// Generate the method code first to extract docstring
			templateData := createMethodTemplateData(v, "axios", false)
			methodCode, err := executeMethodTemplate(axiosMethodTemplate, templateData)

			if err != nil {
				// Fallback to original approach without docstring extraction
				content.WriteString(fmt.Sprintf("%s%s: ", indentStr, quotedKey))
				generateAxiosMethodImplementationLegacy(content, v, indent)
			} else {
				// Extract docstring and method body separately
				lines := strings.Split(methodCode, "\n")
				var docstringLines []string
				var methodBodyLines []string
				inDocstring := false

				for _, line := range lines {
					trimmedLine := strings.TrimSpace(line)
					if strings.HasPrefix(trimmedLine, "/**") {
						inDocstring = true
						docstringLines = append(docstringLines, line)
					} else if inDocstring && strings.HasSuffix(trimmedLine, "*/") {
						inDocstring = false
						docstringLines = append(docstringLines, line)
					} else if inDocstring {
						docstringLines = append(docstringLines, line)
					} else {
						methodBodyLines = append(methodBodyLines, line)
					}
				}

				// Write docstring first (with proper indentation)
				if len(docstringLines) > 0 {
					for _, line := range docstringLines {
						if line != "" {
							content.WriteString(indentStr)
						}
						content.WriteString(line)
						content.WriteString("\n")
					}
				}

				// Write property name and method body
				content.WriteString(fmt.Sprintf("%s%s: ", indentStr, quotedKey))

				// Write method body (skip empty first line if it exists)
				for j, line := range methodBodyLines {
					if j == 0 && strings.TrimSpace(line) == "" {
						continue
					}
					if j > 0 && line != "" {
						content.WriteString(indentStr)
					}
					content.WriteString(line)
					if j < len(methodBodyLines)-1 {
						content.WriteString("\n")
					}
				}
			}
		case types.NestedAPI:
			content.WriteString(fmt.Sprintf("%s%s: {\n", indentStr, quotedKey))
			generateAxiosNestedObject(content, v, indent+1)
			content.WriteString(fmt.Sprintf("%s}", indentStr))
		}

		if i < len(keys)-1 {
			content.WriteString(",")
		}
		content.WriteString("\n")
	}
}

// generateAxiosMethodImplementation generates Axios method implementations
func generateAxiosMethodImplementation(content *strings.Builder, method types.APIMethod, indent int) {
	// Create method template data
	templateData := createMethodTemplateData(method, "axios", false)

	// Execute the axios method template
	methodCode, err := executeMethodTemplate(axiosMethodTemplate, templateData)
	if err != nil {
		// Fallback to original implementation if template fails
		generateAxiosMethodImplementationLegacy(content, method, indent)
		return
	}

	// Apply proper indentation to each line
	indentStr := strings.Repeat("  ", indent)
	lines := strings.Split(methodCode, "\n")
	for i, line := range lines {
		if i > 0 && line != "" {
			content.WriteString(indentStr)
		}
		content.WriteString(line)
		if i < len(lines)-1 {
			content.WriteString("\n")
		}
	}
}

// generateAxiosMethodImplementationLegacy is the original implementation as fallback
func generateAxiosMethodImplementationLegacy(content *strings.Builder, method types.APIMethod, indent int) {
	route := method.Route
	routePath := route.Path[4:] // Remove "/api" prefix

	// Build parameter list
	var params []string
	if method.HasIDParam {
		params = append(params, "id: number")
	}
	if method.HasBodyData {
		requestType := route.RequestType
		if route.Method == "POST" && !strings.Contains(requestType, "Omit") {
			requestType = fmt.Sprintf("Omit<%s, 'id'>", requestType)
		} else if (route.Method == "PUT" || route.Method == "PATCH") && !strings.Contains(requestType, "Partial") {
			requestType = fmt.Sprintf("Partial<%s>", requestType)
		}
		params = append(params, "data: "+requestType)
	}

	responseType := route.ResponseType
	if responseType == "" {
		responseType = "unknown"
	}

	paramStr := strings.Join(params, ", ")

	// Build request path with parameter substitution
	requestPath := routePath
	if method.HasIDParam {
		re1 := regexp.MustCompile(`/:[^/]+`)
		requestPath = re1.ReplaceAllString(requestPath, "/$${id}")
		re2 := regexp.MustCompile(`/\{[^}]+\}`)
		requestPath = re2.ReplaceAllString(requestPath, "/$${id}")
	}

	// Generate async function
	content.WriteString(fmt.Sprintf("async (%s): Promise<AxiosResponse<%s>> => {\n", paramStr, responseType))
	indentStr := strings.Repeat("  ", indent+1)

	if method.HasBodyData {
		content.WriteString(fmt.Sprintf("%sreturn apiClient.%s(`%s`, data)\n", indentStr, strings.ToLower(route.Method), requestPath))
	} else {
		content.WriteString(fmt.Sprintf("%sreturn apiClient.%s(`%s`)\n", indentStr, strings.ToLower(route.Method), requestPath))
	}

	content.WriteString(fmt.Sprintf("%s}", strings.Repeat("  ", indent)))
}

// createMethodTemplateData creates template data for individual method templates
func createMethodTemplateData(method types.APIMethod, generatorType string, reactQueryEnabled bool) MethodTemplateData {
	route := method.Route
	routePath := route.Path[4:] // Remove "/api" prefix

	// Build parameter list
	var params []string
	if method.HasIDParam {
		params = append(params, "id: number")
	}
	if method.HasBodyData {
		requestType := route.RequestType
		if route.Method == "POST" && !strings.Contains(requestType, "Omit") {
			requestType = fmt.Sprintf("Omit<%s, 'id'>", requestType)
		} else if (route.Method == "PUT" || route.Method == "PATCH") && !strings.Contains(requestType, "Partial") {
			requestType = fmt.Sprintf("Partial<%s>", requestType)
		}
		params = append(params, "data: "+requestType)
	}

	responseType := route.ResponseType
	if responseType == "" {
		responseType = "unknown"
	}

	// Build request path with parameter substitution
	requestPath := routePath
	if method.HasIDParam {
		re1 := regexp.MustCompile(`/:[^/]+`)
		requestPath = re1.ReplaceAllString(requestPath, "/$${id}")
		re2 := regexp.MustCompile(`/\{[^}]+\}`)
		requestPath = re2.ReplaceAllString(requestPath, "/$${id}")
	}

	// Determine data parameter name based on generator type
	dataParameter := "data"
	if generatorType == "trpc-like" && reactQueryEnabled {
		// For tRPC mutations with React Query hooks, but not for the raw mutate function
		// The raw mutate function always uses the actual parameter names
		dataParameter = "data"
	}

	// Build mutation variable type for tRPC
	var mutationVariableType string
	if method.HasIDParam && method.HasBodyData {
		requestType := route.RequestType
		if route.Method == "POST" && !strings.Contains(requestType, "Omit") {
			requestType = fmt.Sprintf("Omit<%s, 'id'>", requestType)
		} else if (route.Method == "PUT" || route.Method == "PATCH") && !strings.Contains(requestType, "Partial") {
			requestType = fmt.Sprintf("Partial<%s>", requestType)
		}
		mutationVariableType = fmt.Sprintf("{ id: number; data: %s }", requestType)
	} else if method.HasIDParam {
		mutationVariableType = "number"
	} else if method.HasBodyData {
		requestType := route.RequestType
		if route.Method == "POST" && !strings.Contains(requestType, "Omit") {
			requestType = fmt.Sprintf("Omit<%s, 'id'>", requestType)
		} else if (route.Method == "PUT" || route.Method == "PATCH") && !strings.Contains(requestType, "Partial") {
			requestType = fmt.Sprintf("Partial<%s>", requestType)
		}
		mutationVariableType = requestType
	} else {
		mutationVariableType = "void"
	}

	// Build query parameter signatures for tRPC
	var queryParamSig, queryOptionsParamSig string
	if method.HasIDParam {
		queryParamSig = "id: number, "
		queryOptionsParamSig = "id: number"
	}

	// Build request path for mutations (React Query uses different variable patterns)
	requestPathForMutation := requestPath
	if generatorType == "trpc-like" && reactQueryEnabled && method.HasIDParam {
		if method.HasBodyData {
			// Use variables.id for PUT/PATCH with both ID and body
			re1 := regexp.MustCompile(`\$\{id\}`)
			requestPathForMutation = re1.ReplaceAllString(requestPath, "${variables.id}")
		} else {
			// Use variables directly for DELETE
			re1 := regexp.MustCompile(`\$\{id\}`)
			requestPathForMutation = re1.ReplaceAllString(requestPath, "${variables}")
		}
	}

	return MethodTemplateData{
		Description:                    route.Description,
		Method:                         route.Method,
		MethodLower:                    strings.ToLower(route.Method),
		ParameterSignature:             strings.Join(params, ", "),
		QueryParameterSignature:        queryParamSig,
		QueryOptionsParameterSignature: queryOptionsParamSig,
		ResponseType:                   responseType,
		RequestPath:                    requestPath,
		RequestPathForMutation:         requestPathForMutation,
		HasIDParam:                     method.HasIDParam,
		HasBodyData:                    method.HasBodyData,
		DataParameter:                  dataParameter,
		QueryKey:                       strings.TrimPrefix(route.Path, "/api/"),
		MutationVariableType:           mutationVariableType,
		ReactQueryEnabled:              reactQueryEnabled,
	}
}

// executeMethodTemplate executes a method template and returns the generated code
func executeMethodTemplate(templateStr string, data MethodTemplateData) (string, error) {
	// Create custom function map for templates
	funcMap := template.FuncMap{
		"eq":  func(a, b string) bool { return a == b },
		"and": func(a, b bool) bool { return a && b },
	}

	tmpl, err := template.New("method").Funcs(funcMap).Parse(templateStr)
	if err != nil {
		return "", fmt.Errorf("failed to parse method template: %w", err)
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute method template: %w", err)
	}

	return buf.String(), nil
}
