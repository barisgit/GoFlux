package generator

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"github.com/barisgit/goflux/internal/typegen/types"
	"github.com/barisgit/goflux/templates"
)

// GenerateTypeScriptTypes generates TypeScript type definitions
func GenerateTypeScriptTypes(typeDefs []types.TypeDefinition) error {
	typesDir := filepath.Join("frontend", "src", "types")
	if err := os.MkdirAll(typesDir, 0755); err != nil {
		return err
	}

	var content strings.Builder
	content.WriteString("// Auto-generated TypeScript types from Go structs\n")
	content.WriteString("// Generated by GoFlux type generation system\n")
	content.WriteString("// Do not edit manually\n\n")

	// Sort types for consistent output
	sort.Slice(typeDefs, func(i, j int) bool {
		return typeDefs[i].Name < typeDefs[j].Name
	})

	for _, t := range typeDefs {
		if t.IsEnum {
			// Generate enum type
			content.WriteString(fmt.Sprintf("export type %s = %s\n\n",
				t.Name, strings.Join(t.EnumValues, " | ")))
		} else {
			// Generate interface
			content.WriteString(fmt.Sprintf("export interface %s {\n", t.Name))

			for _, field := range t.Fields {
				fieldName := field.JSONTag
				if fieldName == "" {
					fieldName = toSnakeCase(field.Name)
				}

				optional := ""
				if field.Optional {
					optional = "?"
				}

				content.WriteString(fmt.Sprintf("  %s%s: %s\n",
					fieldName, optional, field.TypeName))
			}

			content.WriteString("}\n\n")
		}
	}

	typesFile := filepath.Join(typesDir, "generated.d.ts")
	return os.WriteFile(typesFile, []byte(content.String()), 0644)
}

// GenerateAPIClient generates the TypeScript API client
func GenerateAPIClient(routes []types.APIRoute, typeDefs []types.TypeDefinition) error {
	libDir := filepath.Join("frontend", "src", "lib")
	if err := os.MkdirAll(libDir, 0755); err != nil {
		return err
	}

	var content strings.Builder
	content.WriteString("// Auto-generated API client from Go routes\n")
	content.WriteString("// Generated by GoFlux type generation system\n")
	content.WriteString("// Do not edit manually\n\n")

	// Collect types that are actually used in API methods
	usedTypes := make(map[string]bool)
	for _, route := range routes {
		if route.RequestType != "" {
			// Extract base type from Omit<Type, 'id'> or Partial<Type>
			requestType := route.RequestType
			if strings.Contains(requestType, "Omit<") {
				start := strings.Index(requestType, "Omit<") + 5
				end := strings.Index(requestType[start:], ",")
				if end > 0 {
					usedTypes[requestType[start:start+end]] = true
				}
			} else if strings.Contains(requestType, "Partial<") {
				start := strings.Index(requestType, "Partial<") + 8
				end := strings.Index(requestType[start:], ">")
				if end > 0 {
					usedTypes[requestType[start:start+end]] = true
				}
			} else {
				usedTypes[requestType] = true
			}
		}
		if route.ResponseType != "" {
			responseType := route.ResponseType
			// Handle array types like "User[]"
			if strings.TrimSuffix(responseType, "[]") != responseType {
				responseType = strings.TrimSuffix(responseType, "[]")
			}
			usedTypes[responseType] = true
		}
	}

	// Import only directly used types
	if len(usedTypes) > 0 {
		var typeNames []string
		for typeName := range usedTypes {
			// Only include types that exist in our generated types
			for _, t := range typeDefs {
				if t.Name == typeName {
					typeNames = append(typeNames, typeName)
					break
				}
			}
		}
		if len(typeNames) > 0 {
			sort.Strings(typeNames) // Sort for consistent output
			content.WriteString(fmt.Sprintf("import type { %s } from '../types/generated'\n\n", strings.Join(typeNames, ", ")))
		}
	}

	// Types for Huma's RFC 9457 Problem Details error format
	content.WriteString("export interface HumaErrorDetail {\n")
	content.WriteString("  message: string\n")
	content.WriteString("  location: string\n")
	content.WriteString("  value: any\n")
	content.WriteString("}\n\n")

	content.WriteString("export interface HumaError {\n")
	content.WriteString("  $schema?: string\n")
	content.WriteString("  title: string\n")
	content.WriteString("  status: number\n")
	content.WriteString("  detail: string\n")
	content.WriteString("  errors?: HumaErrorDetail[]\n")
	content.WriteString("}\n\n")

	// Result type for API responses - union of success or error
	content.WriteString("export type ApiResult<T> = \n")
	content.WriteString("  | { success: true; data: T }\n")
	content.WriteString("  | { success: false; error: HumaError; data: T }\n\n")

	// Base request function
	content.WriteString("async function request<T>(path: string, options: RequestInit = {}): Promise<ApiResult<T>> {\n")
	content.WriteString("  try {\n")
	content.WriteString("    const response = await fetch(`/api${path}`, {\n")
	content.WriteString("      headers: {\n")
	content.WriteString("        'Content-Type': 'application/json',\n")
	content.WriteString("        ...options.headers,\n")
	content.WriteString("      },\n")
	content.WriteString("      ...options,\n")
	content.WriteString("    })\n\n")

	content.WriteString("    if (!response.ok) {\n")
	content.WriteString("      try {\n")
	content.WriteString("        // Try to parse Huma error format\n")
	content.WriteString("        const errorData = await response.json()\n")
	content.WriteString("        return { success: false, error: errorData, data: {} as T }\n")
	content.WriteString("      } catch {\n")
	content.WriteString("        // Fallback to simple error if JSON parsing fails\n")
	content.WriteString("        const errorText = await response.text()\n")
	content.WriteString("        return { \n")
	content.WriteString("          success: false, \n")
	content.WriteString("          error: {\n")
	content.WriteString("            title: response.statusText,\n")
	content.WriteString("            status: response.status,\n")
	content.WriteString("            detail: errorText || response.statusText\n")
	content.WriteString("          },\n")
	content.WriteString("          data: {} as T\n")
	content.WriteString("        }\n")
	content.WriteString("      }\n")
	content.WriteString("    }\n\n")

	content.WriteString("    const data = await response.json()\n")
	content.WriteString("    return { success: true, data }\n")
	content.WriteString("  } catch (error) {\n")
	content.WriteString("    return { \n")
	content.WriteString("      success: false, \n")
	content.WriteString("      error: {\n")
	content.WriteString("        title: 'Network Error',\n")
	content.WriteString("        status: 0,\n")
	content.WriteString("        detail: error instanceof Error ? error.message : 'Unknown error'\n")
	content.WriteString("      },\n")
	content.WriteString("      data: {} as T\n")
	content.WriteString("    }\n")
	content.WriteString("  }\n")
	content.WriteString("}\n\n")

	// Build nested structure from routes
	nestedAPI := buildNestedAPIStructure(routes)

	// Generate the nested API object
	content.WriteString("export const api = {\n")
	generateNestedObject(&content, nestedAPI, 1)
	content.WriteString("}\n\n")

	// Generate type for the API object
	content.WriteString("export type API = typeof api\n")

	clientFile := filepath.Join(libDir, "api-client.ts")
	return os.WriteFile(clientFile, []byte(content.String()), 0644)
}

// GenerateRouteManifest generates a JSON manifest of all routes
func GenerateRouteManifest(routes []types.APIRoute) error {
	manifestDir := filepath.Join("internal", "static")
	if err := os.MkdirAll(manifestDir, 0755); err != nil {
		return err
	}

	manifestFile := filepath.Join(manifestDir, "routes.json")

	data, err := json.MarshalIndent(routes, "", "  ")
	if err != nil {
		return err
	}

	return os.WriteFile(manifestFile, data, 0644)
}

// Helper function to generate a file from an embedded template
func generateFileFromEmbeddedTemplate(templatePath, outputPath string, data interface{}) error {
	// Read template content from embedded filesystem
	content, err := templates.TemplatesFS.ReadFile(templatePath)
	if err != nil {
		return fmt.Errorf("failed to read embedded template %s: %w", templatePath, err)
	}

	// Parse template
	tmpl, err := template.New(filepath.Base(templatePath)).Parse(string(content))
	if err != nil {
		return fmt.Errorf("failed to parse template %s: %w", templatePath, err)
	}

	// Create output directory
	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return fmt.Errorf("failed to create directory for %s: %w", outputPath, err)
	}

	// Create output file
	outputFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file %s: %w", outputPath, err)
	}
	defer outputFile.Close()

	// Execute template
	if err := tmpl.Execute(outputFile, data); err != nil {
		return fmt.Errorf("failed to execute template %s: %w", templatePath, err)
	}

	return nil
}

// Helper function to generate a file from a template (legacy - keeping for compatibility)
func generateFileFromTemplate(templatePath, outputPath string, data interface{}) error {
	// This is now a wrapper that calls the embedded version
	return generateFileFromEmbeddedTemplate(templatePath, outputPath, data)
}

// Helper functions

func buildNestedAPIStructure(routes []types.APIRoute) types.NestedAPI {
	nested := make(types.NestedAPI)

	for _, route := range routes {
		if generateMethodName(route) == "" {
			continue // Skip SSR routes
		}

		path := strings.Replace(route.Path, "/api/", "", 1)
		path = strings.TrimPrefix(path, "/")
		pathParts := strings.Split(path, "/")

		// Filter out parameter parts and build resource hierarchy
		var resourceParts []string
		hasIDParam := false

		for _, part := range pathParts {
			if strings.Contains(part, ":") || strings.HasPrefix(part, "{") {
				hasIDParam = true
				// Don't add parameter parts to resourceParts
			} else if part != "" {
				resourceParts = append(resourceParts, part)
			}
		}

		if len(resourceParts) == 0 {
			continue
		}

		// Determine method name based on HTTP method and context
		methodName := getMethodNameForHTTPMethod(route.Method, hasIDParam, len(resourceParts) > 1)

		method := types.APIMethod{
			Route:       route,
			MethodName:  methodName,
			HasIDParam:  hasIDParam,
			HasBodyData: route.RequestType != "",
		}

		// Build nested structure - but only use the resource parts, not parameters
		current := nested
		for i, part := range resourceParts {
			if i == len(resourceParts)-1 {
				// Last part - this is where we place the method
				if current[part] == nil {
					current[part] = make(types.NestedAPI)
				}
				if nestedPart, ok := current[part].(types.NestedAPI); ok {
					nestedPart[methodName] = method
				}
			} else {
				// Intermediate part - create nested structure
				if current[part] == nil {
					current[part] = make(types.NestedAPI)
				}
				if nestedPart, ok := current[part].(types.NestedAPI); ok {
					current = nestedPart
				}
			}
		}
	}

	return nested
}

func getMethodNameForHTTPMethod(httpMethod string, hasIDParam bool, isNested bool) string {
	switch httpMethod {
	case "GET":
		if hasIDParam {
			return "get"
		}
		return "list"
	case "POST":
		return "create"
	case "PUT", "PATCH":
		return "update"
	case "DELETE":
		return "delete"
	default:
		return strings.ToLower(httpMethod)
	}
}

func generateNestedObject(content *strings.Builder, nested types.NestedAPI, indent int) {
	indentStr := strings.Repeat("  ", indent)

	// Sort keys for consistent output
	keys := make([]string, 0, len(nested))
	for key := range nested {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	for i, key := range keys {
		value := nested[key]

		// Quote key if it contains hyphens or other special characters
		quotedKey := key
		if strings.Contains(key, "-") || strings.Contains(key, " ") || !isValidJSIdentifier(key) {
			quotedKey = fmt.Sprintf(`"%s"`, key)
		}

		switch v := value.(type) {
		case types.APIMethod:
			// Generate method implementation
			content.WriteString(fmt.Sprintf("%s%s: ", indentStr, quotedKey))
			generateMethodImplementation(content, v, indent)
		case types.NestedAPI:
			// Generate nested object
			content.WriteString(fmt.Sprintf("%s%s: {\n", indentStr, quotedKey))
			generateNestedObject(content, v, indent+1)
			content.WriteString(fmt.Sprintf("%s}", indentStr))
		}

		if i < len(keys)-1 {
			content.WriteString(",")
		}
		content.WriteString("\n")
	}
}

func generateMethodImplementation(content *strings.Builder, method types.APIMethod, indent int) {
	route := method.Route
	routePath := route.Path[4:] // Remove "/api" prefix

	// Build parameter list
	var params []string
	if method.HasIDParam {
		params = append(params, "id: number")
	}
	if method.HasBodyData {
		requestType := route.RequestType
		if route.Method == "POST" && !strings.Contains(requestType, "Omit") {
			requestType = fmt.Sprintf("Omit<%s, 'id'>", requestType)
		} else if (route.Method == "PUT" || route.Method == "PATCH") && !strings.Contains(requestType, "Partial") {
			requestType = fmt.Sprintf("Partial<%s>", requestType)
		}
		params = append(params, "data: "+requestType)
	}

	responseType := route.ResponseType
	if responseType == "" {
		responseType = "any"
	}

	paramStr := strings.Join(params, ", ")

	// Generate async function
	content.WriteString(fmt.Sprintf("async (%s): Promise<ApiResult<%s>> => {\n", paramStr, responseType))

	// Build request path with parameter substitution
	requestPath := routePath

	if method.HasIDParam {
		// Replace both :param and {param} patterns with ${id}
		// Handle :param format (like Express.js)
		re1 := regexp.MustCompile(`/:[^/]+`)
		requestPath = re1.ReplaceAllString(requestPath, "/$${id}")

		// Handle {param} format (like OpenAPI)
		re2 := regexp.MustCompile(`/\{[^}]+\}`)
		requestPath = re2.ReplaceAllString(requestPath, "/$${id}")
	}

	indentStr := strings.Repeat("  ", indent+1)
	if method.HasBodyData {
		content.WriteString(fmt.Sprintf("%sreturn request<%s>(`%s`, {\n", indentStr, responseType, requestPath))
		content.WriteString(fmt.Sprintf("%s  method: '%s',\n", indentStr, route.Method))
		content.WriteString(fmt.Sprintf("%s  body: JSON.stringify(data),\n", indentStr))
		content.WriteString(fmt.Sprintf("%s})\n", indentStr))
	} else {
		if route.Method == "GET" {
			content.WriteString(fmt.Sprintf("%sreturn request<%s>(`%s`)\n", indentStr, responseType, requestPath))
		} else {
			content.WriteString(fmt.Sprintf("%sreturn request<%s>(`%s`, { method: '%s' })\n", indentStr, responseType, requestPath, route.Method))
		}
	}

	content.WriteString(fmt.Sprintf("%s}", strings.Repeat("  ", indent)))
}

func generateMethodName(route types.APIRoute) string {
	path := strings.Replace(route.Path, "/api/", "", 1)
	path = strings.TrimPrefix(path, "/")

	// Skip SSR routes
	if strings.Contains(path, "ssr-data") {
		return ""
	}

	// Handle nested routes like /users/:id/profile
	pathParts := strings.Split(path, "/")
	var resourceParts []string
	var hasIDParam bool

	for _, part := range pathParts {
		if strings.Contains(part, ":") {
			hasIDParam = true
		} else if part != "" {
			// Clean up invalid characters
			cleanPart := strings.ReplaceAll(part, "-", "")
			cleanPart = strings.ReplaceAll(cleanPart, ":", "")
			resourceParts = append(resourceParts, cleanPart)
		}
	}

	if len(resourceParts) == 0 {
		return ""
	}

	// Build method name based on route structure
	var methodName string
	switch route.Method {
	case "GET":
		if hasIDParam {
			// For nested routes like /users/:id/profile -> getUserProfile
			if len(resourceParts) > 1 {
				methodName = "get" + capitalize(singularize(resourceParts[0])) + capitalize(resourceParts[1])
			} else {
				methodName = "get" + capitalize(singularize(resourceParts[0]))
			}
		} else {
			// For list routes like /users -> getUsers
			if len(resourceParts) > 1 {
				methodName = "get" + capitalize(resourceParts[0]) + capitalize(resourceParts[1])
			} else {
				methodName = "get" + capitalize(resourceParts[0])
			}
		}
	case "POST":
		if len(resourceParts) > 1 {
			methodName = "create" + capitalize(singularize(resourceParts[0])) + capitalize(resourceParts[1])
		} else {
			methodName = "create" + capitalize(singularize(resourceParts[0]))
		}
	case "PUT", "PATCH":
		if len(resourceParts) > 1 {
			methodName = "update" + capitalize(singularize(resourceParts[0])) + capitalize(resourceParts[1])
		} else {
			methodName = "update" + capitalize(singularize(resourceParts[0]))
		}
	case "DELETE":
		if len(resourceParts) > 1 {
			methodName = "delete" + capitalize(singularize(resourceParts[0])) + capitalize(resourceParts[1])
		} else {
			methodName = "delete" + capitalize(singularize(resourceParts[0]))
		}
	default:
		methodName = strings.ToLower(route.Method) + capitalize(strings.Join(resourceParts, ""))
	}

	return methodName
}

func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r - 'A' + 'a')
	}
	return result.String()
}

func capitalize(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func singularize(s string) string {
	if strings.HasSuffix(s, "s") && len(s) > 1 {
		return s[:len(s)-1]
	}
	return s
}

func isValidJSIdentifier(s string) bool {
	if s == "" {
		return false
	}

	// Check if the first character is valid (letter, underscore, or dollar sign)
	firstChar := rune(s[0])
	if !((firstChar >= 'a' && firstChar <= 'z') ||
		(firstChar >= 'A' && firstChar <= 'Z') ||
		firstChar == '_' || firstChar == '$') {
		return false
	}

	// Check if remaining characters are valid (letters, digits, underscores, or dollar signs)
	for _, char := range s[1:] {
		if !((char >= 'a' && char <= 'z') ||
			(char >= 'A' && char <= 'Z') ||
			(char >= '0' && char <= '9') ||
			char == '_' || char == '$') {
			return false
		}
	}

	return true
}
