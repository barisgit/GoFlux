// @ts-nocheck
// Auto-generated Axios API client from Go routes
// Generated by GoFlux type generation system
// Do not edit manually

import axios, { AxiosResponse, AxiosError } from 'axios'
{{if .UsedTypes}}import type { {{join .UsedTypes ", "}} } from '{{.TypesImport}}'{{end}}

{{if .RequiresAuth}}// Enhanced authentication state management with security-first approach
let authToken: string | null = null

// Authentication helper functions with enhanced security
export const auth = {
  setToken: (token: string, useSecureCookie = false) => {
    authToken = token
    
    if (useSecureCookie && typeof document !== 'undefined') {
      // Use secure HttpOnly-like cookie (not actually HttpOnly from client side, but secure)
      const expires = new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours
      document.cookie = `auth_token=${token}; expires=${expires.toUTCString()}; path=/; secure; samesite=strict`
    }
    // Note: For true HttpOnly cookies, your backend needs to set them after login
    // This client-side approach is a fallback for development/simple setups
  },
  
  getToken: (): string | null => {
    // Memory first (most secure - lost on refresh)
    if (authToken) return authToken
    
    // Fallback to cookie if available
    if (typeof document !== 'undefined') {
      const cookieValue = document.cookie
        .split('; ')
        .find(row => row.startsWith('auth_token='))
        ?.split('=')[1]
      
      if (cookieValue) {
        authToken = cookieValue // Cache in memory
        return cookieValue
      }
    }
    
    return null
  },
  
  clearToken: () => {
    authToken = null
    if (typeof document !== 'undefined') {
      document.cookie = 'auth_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; secure; samesite=strict'
    }
  },
  
  isAuthenticated: (): boolean => {
    return !!auth.getToken()
  },
  
  // Method to check if we can handle a route that requires auth
  canAccessRoute: (requiresAuth: boolean): boolean => {
    if (!requiresAuth) return true
    return auth.isAuthenticated()
  }
}

// Authentication error class for better error handling
export class AuthenticationError extends Error {
  constructor(message: string, public requiresAuth: boolean = true) {
    super(message)
    this.name = 'AuthenticationError'
  }
}

{{end}}export interface APIError {
  message: string
  status: number
  details?: any
}

const apiClient = axios.create({
  baseURL: '/api',
  headers: {
    'Content-Type': 'application/json',
  },
})

{{if .RequiresAuth}}// Enhanced request interceptor with route-specific authentication
apiClient.interceptors.request.use((config) => {
  // Only add auth if the route requires it (this would need to be passed per request)
  // For Axios, we'll add auth to all requests but this could be refined
  const token = auth.getToken()
  if (token && config.headers) {
    switch ('{{.AuthType}}') {
      case 'Bearer':
        config.headers.Authorization = `Bearer ${token}`
        break
      case 'Basic':
        config.headers.Authorization = `Basic ${token}`
        break
      case 'ApiKey':
        config.headers['X-API-Key'] = token
        break
      default:
        config.headers.Authorization = `{{.AuthType}} ${token}`
    }
  }
  return config
})

// Enhanced response interceptor with better error handling
apiClient.interceptors.response.use(
  (response) => response,
  (error: AxiosError) => {
    if (error.response?.status === 401) {
      // Clear invalid token
      auth.clearToken()
    }
    
    const apiError: APIError = {
      message: error.message,
      status: error.response?.status || 0,
      details: error.response?.data,
    }
    return Promise.reject(apiError)
  }
)

{{else}}apiClient.interceptors.response.use(
  (response) => response,
  (error: AxiosError) => {
    const apiError: APIError = {
      message: error.message,
      status: error.response?.status || 0,
      details: error.response?.data,
    }
    return Promise.reject(apiError)
  }
)

{{end}}

{{.APIObject}}

export type API = typeof api 